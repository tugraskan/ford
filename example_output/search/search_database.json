var tipuesearch = {"pages":[{"title":" Test Project ","text":"Test Project Developer Info Test","tags":"home","url":"index.html"},{"title":"foo – Test Project ","text":"type :: foo Components Type Visibility Attributes Name Initial integer, public :: foo_stuff Type-Bound Procedures procedure, public :: do_foo_stuff subroutine do_foo_stuff (this) Arguments Type Intent Optional Attributes Name class( foo ) :: this","tags":"","url":"type/foo.html"},{"title":"bar – Test Project ","text":"type, extends( foo ) :: bar Components Type Visibility Attributes Name Initial integer, public :: foo_stuff Type-Bound Procedures procedure, public :: do_foo_stuff subroutine do_foo_stuff (this) Arguments Type Intent Optional Attributes Name class( foo ) :: this","tags":"","url":"type/bar.html"},{"title":"test_io_procedure – Test Project","text":"public  subroutine test_io_procedure(filename, num_records) Subroutine that demonstrates I/O operations and local variables Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Name of the file to write integer, intent(in) :: num_records Number of records to write I/O Operations Unit unit_unit_num Operation Details Line write write(unit_num, '(A)') 'Test data file' 31 write write(unit_num, '(A,I0)') 'Number of records: ', num_records 32 write write(unit_num, '(I5,F15.6)') i, local_var 39 close close(unit_num) 43 close close(unit_num) - Unit filename, status='unknown', action='write No operations recorded Unit unit_output_unit Operation Details Line write write(output_unit, '(A,A)') 'Wrote data to file: ', filename 46 Variables Type Visibility Attributes Name Initial character(len=*), public :: filename Name of the file to write integer, public :: num_records Number of records to write Source Code subroutine test_io_procedure ( filename , num_records ) !! Subroutine that demonstrates I/O operations and local variables character ( len =* ), intent ( in ) :: filename !! Name of the file to write integer , intent ( in ) :: num_records !! Number of records to write ! Local variables integer :: unit_num = 10 integer :: i , j real ( dp ) :: local_var = 3.14159 character ( len = 100 ) :: buffer logical :: file_exists ! Check if file exists inquire ( file = filename , exist = file_exists ) ! Open file for writing open ( unit = unit_num , file = filename , status = 'unknown' , action = 'write' ) ! Write header write ( unit_num , '(A)' ) 'Test data file' write ( unit_num , '(A,I0)' ) 'Number of records: ' , num_records ! Write data records do i = 1 , num_records do j = 1 , 3 local_var = local_var + real ( i * j , dp ) end do write ( unit_num , '(I5,F15.6)' ) i , local_var end do ! Close file close ( unit_num ) ! Write status to output write ( output_unit , '(A,A)' ) 'Wrote data to file: ' , filename end subroutine test_io_procedure","tags":"","url":"proc/test_io_procedure.html"},{"title":"do_foo_stuff – Test Project","text":"subroutine do_foo_stuff(this) Type Bound foo Arguments Type Intent Optional Attributes Name class( foo ) :: this Variables Type Visibility Attributes Name Initial class( foo ), public :: this","tags":"","url":"proc/do_foo_stuff.html"},{"title":"do_stuff – Test Project","text":"subroutine do_stuff(repeat) This is documentation for our subroutine that does stuff and things.\nThis text is captured by ford Arguments Type Intent Optional Attributes Name integer, intent(in) :: repeat The number of times to repeatedly do stuff and things Variables Type Visibility Attributes Name Initial integer, public :: repeat The number of times to repeatedly do stuff and things Source Code subroutine do_stuff ( repeat ) !! This is documentation for our subroutine that does stuff and things. !! This text is captured by ford integer , intent ( in ) :: repeat !! The number of times to repeatedly do stuff and things integer :: i !! internal loop counter ! the main content goes here and this is comment is not processed by FORD do i = 1 , repeat global_pi = acos ( - 1 ) end do end subroutine do_stuff","tags":"","url":"proc/do_stuff.html"},{"title":"linalg – Test Project","text":"subroutine linalg(A, x, b) Solve Ax = b with linear algebra magic Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:,:) The a matrix to invert etc. real, intent(out) :: x (:) The solution to Ax = b do some stuff, ensure proper bounds etc. real, intent(in) :: b (:) The right hand side Variables Type Visibility Attributes Name Initial real, public :: A (:,:) The a matrix to invert etc. real, public :: x (:) The solution to Ax = b do some stuff, ensure proper bounds etc. real, public :: b (:) The right hand side Source Code subroutine linalg ( A , x , b ) !! Solve Ax = b with linear algebra magic real , intent ( in ) :: A (:,:) !! The a matrix to invert etc. real , intent ( in ) :: b (:) !! The right hand side real , intent ( out ) :: x (:) !! The solution to Ax = b !! do some stuff, ensure proper bounds etc. end subroutine linalg","tags":"","url":"proc/linalg.html"},{"title":"test_module – Test Project","text":"Test module with procedures that have local variables and I/O operations Uses iso_fortran_env Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = selected_real_kind(15, 307) Subroutines public  subroutine test_io_procedure (filename, num_records) Subroutine that demonstrates I/O operations and local variables Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Name of the file to write integer, intent(in) :: num_records Number of records to write","tags":"","url":"module/test_module.html"},{"title":"ford_test_program – Test Project","text":"Uses iso_fortran_env Simple Fortran program to demonstrate the usage of FORD and to test its installation Variables Type Attributes Name Initial real(kind=real64) :: global_pi = acos(-1) a global variable, initialized to the value of pi Derived Types type :: foo Components Type Visibility Attributes Name Initial integer, public :: foo_stuff Type-Bound Procedures procedure, public :: do_foo_stuff type, extends( foo ) :: bar Components Type Visibility Attributes Name Initial integer, public :: foo_stuff Type-Bound Procedures procedure, public :: do_foo_stuff Subroutines subroutine do_foo_stuff (this) Arguments Type Intent Optional Attributes Name class( foo ) :: this subroutine do_stuff (repeat) This is documentation for our subroutine that does stuff and things.\nThis text is captured by ford Arguments Type Intent Optional Attributes Name integer, intent(in) :: repeat The number of times to repeatedly do stuff and things subroutine linalg (A, x, b) Solve Ax = b with linear algebra magic Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:,:) The a matrix to invert etc. real, intent(out) :: x (:) The solution to Ax = b Read more … Read more… real, intent(in) :: b (:) The right hand side Source Code program ford_test_program !! Simple Fortran program to demonstrate the usage of FORD and to test its installation use iso_fortran_env , only : output_unit , real64 implicit none real ( real64 ) :: global_pi = acos ( - 1 ) !! a global variable, initialized to the value of pi type foo integer :: foo_stuff contains procedure :: do_foo_stuff end type type , extends ( foo ) :: bar end type write ( output_unit , '(A)' ) 'Small test program' call do_stuff ( 20 ) contains subroutine do_foo_stuff ( this ) class ( foo ) :: this end subroutine subroutine do_stuff ( repeat ) !! This is documentation for our subroutine that does stuff and things. !! This text is captured by ford integer , intent ( in ) :: repeat !! The number of times to repeatedly do stuff and things integer :: i !! internal loop counter ! the main content goes here and this is comment is not processed by FORD do i = 1 , repeat global_pi = acos ( - 1 ) end do end subroutine do_stuff subroutine linalg ( A , x , b ) !! Solve Ax = b with linear algebra magic real , intent ( in ) :: A (:,:) !! The a matrix to invert etc. real , intent ( in ) :: b (:) !! The right hand side real , intent ( out ) :: x (:) !! The solution to Ax = b !! do some stuff, ensure proper bounds etc. end subroutine linalg end program ford_test_program","tags":"","url":"program/ford_test_program.html"},{"title":"test_module.f90 – Test Project","text":"Source Code module test_module !! Test module with procedures that have local variables and I/O operations use iso_fortran_env , only : output_unit implicit none integer , parameter :: dp = selected_real_kind ( 15 , 307 ) contains subroutine test_io_procedure ( filename , num_records ) !! Subroutine that demonstrates I/O operations and local variables character ( len =* ), intent ( in ) :: filename !! Name of the file to write integer , intent ( in ) :: num_records !! Number of records to write ! Local variables integer :: unit_num = 10 integer :: i , j real ( dp ) :: local_var = 3.14159 character ( len = 100 ) :: buffer logical :: file_exists ! Check if file exists inquire ( file = filename , exist = file_exists ) ! Open file for writing open ( unit = unit_num , file = filename , status = 'unknown' , action = 'write' ) ! Write header write ( unit_num , '(A)' ) 'Test data file' write ( unit_num , '(A,I0)' ) 'Number of records: ' , num_records ! Write data records do i = 1 , num_records do j = 1 , 3 local_var = local_var + real ( i * j , dp ) end do write ( unit_num , '(I5,F15.6)' ) i , local_var end do ! Close file close ( unit_num ) ! Write status to output write ( output_unit , '(A,A)' ) 'Wrote data to file: ' , filename end subroutine test_io_procedure end module test_module","tags":"","url":"sourcefile/test_module.f90.html"},{"title":"ford_test_program.f90 – Test Project","text":"Source Code program ford_test_program !! Simple Fortran program to demonstrate the usage of FORD and to test its installation use iso_fortran_env , only : output_unit , real64 implicit none real ( real64 ) :: global_pi = acos ( - 1 ) !! a global variable, initialized to the value of pi type foo integer :: foo_stuff contains procedure :: do_foo_stuff end type type , extends ( foo ) :: bar end type write ( output_unit , '(A)' ) 'Small test program' call do_stuff ( 20 ) contains subroutine do_foo_stuff ( this ) class ( foo ) :: this end subroutine subroutine do_stuff ( repeat ) !! This is documentation for our subroutine that does stuff and things. !! This text is captured by ford integer , intent ( in ) :: repeat !! The number of times to repeatedly do stuff and things integer :: i !! internal loop counter ! the main content goes here and this is comment is not processed by FORD do i = 1 , repeat global_pi = acos ( - 1 ) end do end subroutine do_stuff subroutine linalg ( A , x , b ) !! Solve Ax = b with linear algebra magic real , intent ( in ) :: A (:,:) !! The a matrix to invert etc. real , intent ( in ) :: b (:) !! The right hand side real , intent ( out ) :: x (:) !! The solution to Ax = b !! do some stuff, ensure proper bounds etc. end subroutine linalg end program ford_test_program","tags":"","url":"sourcefile/ford_test_program.f90.html"}]}